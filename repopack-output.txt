This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-04-17T15:49:19.322Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
integration/
  environments/
    env.bru
  records/
    GetRecords.bru
    PostRecords.bru
  bruno.json
src/
  modules/
    orders/
      controllers/
        orders.controller.ts
      dtos/
        create-order.request.dto.ts
      interfaces/
        orders.service.interface.ts
      schemas/
        orders.schema.ts
      services/
        orders.service.ts
      orders.module.ts
    records/
      controllers/
        record.controller.spec.ts
        record.controller.ts
      dtos/
        create-order.request.dto.ts
        create-record.request.dto.ts
        track-list.request.dto.ts
        update-record.request.dto.ts
      interfaces/
        record.service.interface.ts
      schemas/
        record.enum.ts
        record.schema.ts
      services/
        record.service.spec.ts
        record.service.ts
      record.module.ts
  utils/
    api.ts
    dto.ts
    IMusicBrainz.interface.ts
  app.config.ts
  app.module.ts
  main.ts
test/
  jest-e2e.json
  record.e2e-spec.ts
.env.sample
.eslintrc.js
.gitignore
.prettierrc
CHALLENGE.md
data.json
docker-compose-mongo.yml
jest.config.ts
nest-cli.json
package.json
README.md
setup-db.ts
SOLUTION.md
tsconfig.build.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: integration/environments/env.bru
================
vars {
  BASE_URL: http://localhost:3000
}

================
File: integration/records/GetRecords.bru
================
meta {
  name: GetRecords
  type: http
  seq: 1
}

get {
  url: {{BASE_URL}}/records
  body: none
  auth: none
}

================
File: integration/records/PostRecords.bru
================
meta {
  name: PostRecords
  type: http
  seq: 2
}

post {
  url: {{BASE_URL}}/records
  body: json
  auth: none
}

body:json {
  {
    "artist": "Nirvana",
    "album": "In Utero",
    "price": 12,
    "qty": 10,
    "format": "Digital",
    "category": "Rock",
    "mbid": "eccae410-7577-4daa-b602-92d305828331"
  }
  
}

================
File: integration/bruno.json
================
{
  "version": "1",
  "name": "integration",
  "type": "collection",
  "ignore": [
    "node_modules",
    ".git"
  ]
}

================
File: src/modules/orders/controllers/orders.controller.ts
================
import { Body, Controller, Post } from '@nestjs/common';
import { OrdersService } from '../services/orders.service';
import { CreateOrderRequestDTO } from '../dtos/create-order.request.dto';
import { Orders } from '../schemas/orders.schema';
import { IOrdersService } from '../interfaces/orders.service.interface';

@Controller('orders')
export class OrdersController implements IOrdersService {
  constructor(private readonly ordersService: OrdersService) {}

  @Post()
  async create(@Body() payload: CreateOrderRequestDTO): Promise<Orders> {
    return this.ordersService.create(payload);
  }
}

================
File: src/modules/orders/dtos/create-order.request.dto.ts
================
import { IsString, IsNotEmpty, Min, Max, IsInt } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateOrderRequestDTO {
  @ApiProperty({
    description: 'Record Id',
    type: String,
  })
  @IsString()
  @IsNotEmpty()
  recordId: string;

  @ApiProperty({
    description: 'Quantity of the records',
    type: Number,
    example: 1000,
  })
  @IsInt()
  @Min(0)
  @Max(100)
  qty: number;
}

================
File: src/modules/orders/interfaces/orders.service.interface.ts
================
import { CreateOrderRequestDTO } from '../dtos/create-order.request.dto';
import { Orders } from '../schemas/orders.schema';

export interface IOrdersService {
  create(payload: CreateOrderRequestDTO): Promise<Orders>;
}

================
File: src/modules/orders/schemas/orders.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ timestamps: true })
export class Orders extends Document {
  @Prop({ required: true })
  recordId: string;

  @Prop({ required: true })
  qty: number;
}

export const OrdersSchema = SchemaFactory.createForClass(Orders);

================
File: src/modules/orders/services/orders.service.ts
================
import { Inject, Injectable } from '@nestjs/common';
import { CreateOrderRequestDTO } from '../dtos/create-order.request.dto';
import { Model } from 'mongoose';
import { Orders } from '../schemas/orders.schema';
import { InjectModel } from '@nestjs/mongoose';
import { ClientProxy } from '@nestjs/microservices';
import { firstValueFrom } from 'rxjs';
import { IOrdersService } from '../interfaces/orders.service.interface';

@Injectable()
export class OrdersService implements IOrdersService {
  constructor(
    @Inject('ORDERS_SERVICE') private readonly rabbitQueueClient: ClientProxy,
    @InjectModel('Orders') private readonly ordersModel: Model<Orders>,
  ) {}

  async create(payload: CreateOrderRequestDTO): Promise<Orders> {
    try {
      const recordData = { ...payload };

      const isRecordAvailable = await firstValueFrom(
        this.rabbitQueueClient.send(
          { cmd: 'order:check_availability' },
          recordData,
        ),
      );

      if (!isRecordAvailable) {
        throw new Error('Record is not available');
      }

      await firstValueFrom(
        this.rabbitQueueClient.send({ cmd: 'order:order_placed' }, recordData),
      );

      const createOrderRecord = await this.ordersModel.create(recordData);
      return createOrderRecord;
    } catch (error) {
      throw new Error(`Error creating order: ${error.message}`);
    }
  }
}

================
File: src/modules/orders/orders.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { OrdersController } from './controllers/orders.controller';
import { OrdersService } from './services/orders.service';
import { OrdersSchema } from './schemas/orders.schema';
import { ClientsModule, Transport } from '@nestjs/microservices';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Orders', schema: OrdersSchema }]),
    ClientsModule.register([
      {
        name: 'ORDERS_SERVICE',
        transport: Transport.RMQ,
        options: {
          noAck: false,
          urls: ['amqp://localhost:5672'],
          queue: 'orders-queue',
        },
      },
    ]),
  ],
  controllers: [OrdersController],
  providers: [OrdersService],
})
export class OrdersModule {}

================
File: src/modules/records/controllers/record.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { RecordController } from './record.controller';
import { RecordService } from '../services/record.service';
import { CreateRecordRequestDTO } from '../dtos/create-record.request.dto';
import { RecordFormat, RecordCategory } from '../schemas/record.enum';
import { UpdateRecordRequestDTO } from '../dtos/update-record.request.dto';

describe('RecordController', () => {
  let controller: RecordController;
  let service: RecordService;

  const mockService = {
    create: jest.fn(),
    findAll: jest.fn(),
    update: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [RecordController],
      providers: [{ provide: RecordService, useValue: mockService }],
    }).compile();

    controller = module.get<RecordController>(RecordController);
    service = module.get<RecordService>(RecordService);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('create', () => {
    it('should call service.create and return result', async () => {
      const dto: CreateRecordRequestDTO = {
        artist: 'Radiohead',
        album: 'OK Computer',
        price: 50,
        qty: 5,
        format: RecordFormat.VINYL,
        category: RecordCategory.ROCK,
        mbid: 'some-mbid',
      };

      const createdRecord = { id: '1', ...dto };
      mockService.create.mockResolvedValue(createdRecord);

      const result = await controller.create(dto);
      expect(result).toEqual(createdRecord);
      expect(service.create).toHaveBeenCalledWith(dto);
    });
  });

  describe('findAll', () => {
    it('should call service.findAll and return result', async () => {
      const records = [{ artist: 'Radiohead', album: 'Kid A' }];
      mockService.findAll.mockResolvedValue(records);

      const result = await controller.findAll(10, 0);
      expect(result).toEqual(records);
      expect(service.findAll).toHaveBeenCalledWith(
        10,
        0,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
    });
  });

  describe('update', () => {
    it('should call service.update and return result', async () => {
      const id = 'abc123';
      const dto: UpdateRecordRequestDTO = {
        artist: 'Updated Artist',
        album: 'Updated Album',
        mbid: 'updated-mbid',
      };

      const updatedRecord = { id, ...dto };
      mockService.update.mockResolvedValue(updatedRecord);

      const result = await controller.update(id, dto);
      expect(result).toEqual(updatedRecord);
      expect(service.update).toHaveBeenCalledWith(id, dto);
    });
  });
});

================
File: src/modules/records/controllers/record.controller.ts
================
import { Controller, Get, Post, Body, Param, Query, Put } from '@nestjs/common';
import { Record } from '../schemas/record.schema';
import { ApiOperation, ApiQuery, ApiResponse } from '@nestjs/swagger';
import { CreateRecordRequestDTO } from '../dtos/create-record.request.dto';
import { RecordCategory, RecordFormat } from '../schemas/record.enum';
import { UpdateRecordRequestDTO } from '../dtos/update-record.request.dto';
import { RecordService } from '../services/record.service';
import {
  Ctx,
  MessagePattern,
  Payload,
  RmqContext,
} from '@nestjs/microservices';
import { CreateOrderRequestDTO } from '../dtos/create-order.request.dto';

@Controller('records')
export class RecordController {
  constructor(private readonly recordService: RecordService) {}

  @MessagePattern({ cmd: 'order:check_availability' })
  async checkRecordAvailability(
    @Ctx() context: RmqContext,
    @Payload() payload: CreateOrderRequestDTO,
  ) {
    const channel = context.getChannelRef();
    channel.ack(context.getMessage());
    return this.recordService.checkRecordAvailability(payload);
  }

  @MessagePattern({ cmd: 'order:order_placed' })
  async orderPlaced(
    @Ctx() context: RmqContext,
    @Payload() payload: CreateOrderRequestDTO,
  ) {
    const channel = context.getChannelRef();
    channel.ack(context.getMessage());
    return this.recordService.update(payload.recordId, { qty: payload.qty });
  }

  @Post()
  @ApiOperation({ summary: 'Create a new record' })
  @ApiResponse({
    status: 201,
    description: 'Record successfully created',
    type: [Record],
  })
  @ApiResponse({ status: 400, description: 'Bad Request' })
  async create(@Body() request: CreateRecordRequestDTO): Promise<Record> {
    return this.recordService.create(request);
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update an existing record' })
  @ApiResponse({
    status: 200,
    description: 'Record updated successfully',
    type: [Record],
  })
  @ApiResponse({ status: 500, description: 'Cannot find record to update' })
  async update(
    @Param('id') id: string,
    @Body() updateRecordDto: UpdateRecordRequestDTO,
  ): Promise<Record> {
    return this.recordService.update(id, updateRecordDto);
  }

  @Get()
  @ApiOperation({ summary: 'Get all records with optional filters' })
  @ApiResponse({
    status: 200,
    description: 'List of records',
    type: [Record],
  })
  @ApiQuery({
    name: 'q',
    required: false,
    description:
      'Search query (search across multiple fields like artist, album, category, etc.)',
    type: String,
  })
  @ApiQuery({
    name: 'artist',
    required: false,
    description: 'Filter by artist name',
    type: String,
  })
  @ApiQuery({
    name: 'album',
    required: false,
    description: 'Filter by album name',
    type: String,
  })
  @ApiQuery({
    name: 'format',
    required: false,
    description: 'Filter by record format (Vinyl, CD, etc.)',
    enum: RecordFormat,
    type: String,
  })
  @ApiQuery({
    name: 'category',
    required: false,
    description: 'Filter by record category (e.g., Rock, Jazz)',
    enum: RecordCategory,
    type: String,
  })
  async findAll(
    @Query('limit') limit?: number,
    @Query('skip') skip?: number,
    @Query('q') q?: string,
    @Query('artist') artist?: string,
    @Query('album') album?: string,
    @Query('format') format?: RecordFormat,
    @Query('category') category?: RecordCategory,
  ): Promise<{ data: Record[]; total: number }> {
    return this.recordService.findAll(
      limit,
      skip,
      q,
      artist,
      album,
      format,
      category,
    );
  }
}

================
File: src/modules/records/dtos/create-order.request.dto.ts
================
import { IsString, IsNotEmpty, Min, Max, IsInt } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateOrderRequestDTO {
  @ApiProperty({
    description: 'Record Id',
    type: String,
  })
  @IsString()
  @IsNotEmpty()
  recordId: string;

  @ApiProperty({
    description: 'Quantity of the records',
    type: Number,
    example: 1000,
  })
  @IsInt()
  @Min(0)
  @Max(100)
  qty: number;
}

================
File: src/modules/records/dtos/create-record.request.dto.ts
================
import {
  IsString,
  IsNotEmpty,
  IsNumber,
  Min,
  Max,
  IsInt,
  IsEnum,
  IsOptional,
} from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { RecordFormat, RecordCategory } from '../schemas/record.enum';
import { TrackListDTO } from './track-list.request.dto';

export class CreateRecordRequestDTO {
  @ApiProperty({
    description: 'Artist of the record',
    type: String,
    example: 'The Beatles',
  })
  @IsString()
  @IsNotEmpty()
  artist: string;

  @ApiProperty({
    description: 'Album name',
    type: String,
    example: 'Abbey Road',
  })
  @IsString()
  @IsNotEmpty()
  album: string;

  @ApiProperty({
    description: 'Price of the record',
    type: Number,
    example: 30,
  })
  @IsNumber()
  @Min(0)
  @Max(10000)
  price: number;

  @ApiProperty({
    description: 'Quantity of the record in stock',
    type: Number,
    example: 1000,
  })
  @IsInt()
  @Min(0)
  @Max(100)
  qty: number;

  @ApiProperty({
    description: 'Format of the record (Vinyl, CD, etc.)',
    enum: RecordFormat,
    example: RecordFormat.VINYL,
  })
  @IsEnum(RecordFormat)
  @IsNotEmpty()
  format: RecordFormat;

  @ApiProperty({
    description: 'Category or genre of the record (e.g., Rock, Jazz)',
    enum: RecordCategory,
    example: RecordCategory.ROCK,
  })
  @IsEnum(RecordCategory)
  @IsNotEmpty()
  category: RecordCategory;

  @ApiProperty({
    description: 'Musicbrainz identifier',
    type: String,
    example: 'b10bbbfc-cf9e-42e0-be17-e2c3e1d2600d',
  })
  @IsOptional()
  mbid?: string;

  @ApiProperty({
    description: 'Musicbrainz identifier',
    type: Array<TrackListDTO>,
  })
  trackList?: TrackListDTO[];
}

================
File: src/modules/records/dtos/track-list.request.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';

export class TrackListDTO {
  @ApiProperty({
    description: 'Musicbrainz track id',
    type: String,
  })
  id: string;

  @ApiProperty({
    description: 'Musicbrainz track title',
    type: String,
  })
  title?: string;

  @ApiProperty({
    description: 'Musicbrainz track first release date',
    type: String,
  })
  firstReleaseDate: string;

  @ApiProperty({
    description: 'Musicbrainz track disambiguation',
    type: String,
  })
  disambiguation: string;

  @ApiProperty({
    description: 'Musicbrainz track video flag',
    type: Boolean,
  })
  video: boolean;

  @ApiProperty({
    description: 'Musicbrainz track length',
    type: Number,
  })
  length: number;
}

================
File: src/modules/records/dtos/update-record.request.dto.ts
================
import {
  IsString,
  IsNumber,
  Min,
  Max,
  IsInt,
  IsEnum,
  IsOptional,
} from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { RecordFormat, RecordCategory } from '../schemas/record.enum';
import { TrackListDTO } from './track-list.request.dto';

export class UpdateRecordRequestDTO {
  @ApiProperty({
    description: 'Artist of the record',
    type: String,
    example: 'The Beatles',
    required: false,
  })
  @IsString()
  @IsOptional()
  artist?: string;

  @ApiProperty({
    description: 'Album name',
    type: String,
    example: 'Abbey Road',
    required: false,
  })
  @IsString()
  @IsOptional()
  album?: string;

  @ApiProperty({
    description: 'Price of the record',
    type: Number,
    example: 30,
    required: false,
  })
  @IsNumber()
  @Min(0)
  @Max(10000)
  @IsOptional()
  price?: number;

  @ApiProperty({
    description: 'Quantity of the record in stock',
    type: Number,
    example: 1000,
    required: false,
  })
  @IsInt()
  @Min(0)
  @Max(100)
  @IsOptional()
  qty?: number;

  @ApiProperty({
    description: 'Format of the record (Vinyl, CD, etc.)',
    enum: RecordFormat,
    example: RecordFormat.VINYL,
    required: false,
  })
  @IsEnum(RecordFormat)
  @IsOptional()
  format?: RecordFormat;

  @ApiProperty({
    description: 'Category or genre of the record (e.g., Rock, Jazz)',
    enum: RecordCategory,
    example: RecordCategory.ROCK,
    required: false,
  })
  @IsEnum(RecordCategory)
  @IsOptional()
  category?: RecordCategory;

  @ApiProperty({
    description: 'Musicbrainz identifier',
    type: String,
    example: 'b10bbbfc-cf9e-42e0-be17-e2c3e1d2600d',
    required: false,
  })
  @IsOptional()
  mbid?: string;

  @ApiProperty({
    description: 'Musicbrainz identifier',
    type: Array<TrackListDTO>,
  })
  trackList?: TrackListDTO[];
}

================
File: src/modules/records/interfaces/record.service.interface.ts
================
import { CreateOrderRequestDTO } from '../dtos/create-order.request.dto';
import { CreateRecordRequestDTO } from '../dtos/create-record.request.dto';
import { UpdateRecordRequestDTO } from '../dtos/update-record.request.dto';
import { Record } from '../schemas/record.schema';

export interface IRecordService {
  create(payload: CreateRecordRequestDTO): Promise<Record>;
  update(id: string, payload: UpdateRecordRequestDTO): Promise<Record>;
  findById(id: string): Promise<Record>;
  findAll(): Promise<{ data: Record[]; total: number }>;
  checkRecordAvailability(payload: CreateOrderRequestDTO): Promise<boolean>;
}

================
File: src/modules/records/schemas/record.enum.ts
================
export enum RecordFormat {
  VINYL = 'Vinyl',
  CD = 'CD',
  CASSETTE = 'Cassette',
  DIGITAL = 'Digital',
}

export enum RecordCategory {
  ROCK = 'Rock',
  JAZZ = 'Jazz',
  HIPHOP = 'Hip-Hop',
  CLASSICAL = 'Classical',
  POP = 'Pop',
  ALTERNATIVE = 'Alternative',
  INDIE = 'Indie',
}

================
File: src/modules/records/schemas/record.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';
import { RecordFormat, RecordCategory } from './record.enum';

@Schema({ timestamps: true })
export class Record extends Document {
  @Prop({ required: true })
  artist: string;

  @Prop({ required: true })
  album: string;

  @Prop({ required: true })
  price: number;

  @Prop({ required: true })
  qty: number;

  @Prop({ enum: RecordFormat, required: true })
  format: RecordFormat;

  @Prop({ enum: RecordCategory, required: true })
  category: RecordCategory;

  @Prop({ default: Date.now })
  created: Date;

  @Prop({ default: Date.now })
  lastModified: Date;

  @Prop({ required: false })
  mbid?: string;

  @Prop({ required: false })
  trackList?: Array<{
    id: string;
    title?: string;
    firstReleaseDate: string;
    disambiguation: string;
    video: boolean;
    length: number;
  }>;
}

export const RecordSchema = SchemaFactory.createForClass(Record);
RecordSchema.index({ artist: 1 });
RecordSchema.index({ album: 1 });
RecordSchema.index({ category: 1 });
RecordSchema.index({ format: 1 });
RecordSchema.index({ artist: 'text', album: 'text', category: 'text' });

================
File: src/modules/records/services/record.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { RecordService } from './record.service';
import { getModelToken } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Record } from '../schemas/record.schema';
import { CreateRecordRequestDTO } from '../dtos/create-record.request.dto';
import { UpdateRecordRequestDTO } from '../dtos/update-record.request.dto';
import { RecordCategory, RecordFormat } from '../schemas/record.enum';
import { MusicBrainzService } from 'src/utils/api';

describe('RecordService', () => {
  let service: RecordService;
  let recordModel: Model<Record>;
  let musicBrainzService: MusicBrainzService;

  const mockRecordModel = {
    create: jest.fn(),
    findById: jest.fn(),
    updateOne: jest.fn(),
    find: jest.fn().mockReturnThis(),
    limit: jest.fn().mockReturnThis(),
    skip: jest.fn().mockReturnThis(),
    exec: jest.fn(),
  };

  const mockMusicBrainzService = {
    getReleaseData: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        RecordService,
        {
          provide: getModelToken('Record'),
          useValue: mockRecordModel,
        },
        {
          provide: MusicBrainzService,
          useValue: mockMusicBrainzService,
        },
      ],
    }).compile();

    service = module.get<RecordService>(RecordService);
    recordModel = module.get<Model<Record>>(getModelToken('Record'));
    musicBrainzService = module.get<MusicBrainzService>(MusicBrainzService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('create', () => {
    it('should create a record without MBID', async () => {
      const dto: CreateRecordRequestDTO = {
        artist: 'Artist',
        album: 'Album',
        price: 10,
        qty: 1,
        format: RecordFormat.CD,
        category: RecordCategory.POP,
      };

      const createdRecord = { _id: '1', ...dto };
      mockRecordModel.create.mockResolvedValue(createdRecord);

      const result = await service.create(dto);
      expect(result).toEqual(createdRecord);
      expect(recordModel.create).toHaveBeenCalledWith(dto);
      expect(musicBrainzService.getReleaseData).toHaveBeenCalledTimes(0);
    });

    it('should enrich and create a record with MBID', async () => {
      const dto: CreateRecordRequestDTO = {
        artist: 'Artist',
        album: 'Album',
        price: 10,
        qty: 1,
        format: RecordFormat.VINYL,
        category: RecordCategory.ROCK,
        mbid: '123',
      };

      const mockTracks = [
        {
          recording: {
            id: 'track1',
            title: 'Track 1',
            length: 300000,
            disambiguation: '',
            video: false,
            'first-release-date': '2020-01-01',
          },
        },
      ];

      mockMusicBrainzService.getReleaseData.mockResolvedValue({
        media: [{ tracks: mockTracks }],
      });

      mockRecordModel.create.mockResolvedValue({ _id: '1', ...dto });

      const result = await service.create(dto);
      expect(recordModel.create).toHaveBeenCalled();
      expect(musicBrainzService.getReleaseData).toHaveBeenCalledTimes(1);
      expect(result).toHaveProperty('_id');
    });
  });

  describe('handleOrderPlaced', () => {
    it('should throw if record not found', async () => {
      mockRecordModel.findById.mockResolvedValue(null);

      await expect(
        service.handleOrderPlaced({ recordId: 'notfound', qty: 1 }),
      ).rejects.toThrow('Record not found');
    });

    it('should throw if stock is insufficient', async () => {
      mockRecordModel.findById.mockResolvedValue({ qty: 0 });

      await expect(
        service.handleOrderPlaced({ recordId: '1', qty: 2 }),
      ).rejects.toThrow('Sorry! Not enough stock');
    });

    it('should update the record on order placed', async () => {
      const mockRecord = { _id: '1', qty: 5 };
      mockRecordModel.findById.mockResolvedValue(mockRecord);
      mockRecordModel.updateOne.mockResolvedValue({ acknowledged: true });

      const result = await service.handleOrderPlaced({
        recordId: '1',
        qty: 1,
      });

      expect(result).toEqual(mockRecord);
      expect(recordModel.updateOne).toHaveBeenCalled();
    });
  });

  describe('update', () => {
    it('should update a record with new MBID', async () => {
      const mockRecord = {
        _id: '1',
        mbid: 'old-mbid',
        artist: 'Artist',
        album: 'Album',
      };

      const updateDto: UpdateRecordRequestDTO = {
        mbid: 'new-mbid',
        artist: 'Artist',
        album: 'Album',
      };

      mockRecordModel.findById.mockResolvedValue(mockRecord);
      mockMusicBrainzService.getReleaseData.mockResolvedValue({
        media: [{ tracks: [] }],
      });
      mockRecordModel.updateOne.mockResolvedValue({ acknowledged: true });

      const result = await service.update('1', updateDto);

      expect(result).toEqual(mockRecord);
    });
  });

  describe('findAll', () => {
    it('should return all records filtered', async () => {
      const mockRecords = [
        {
          artist: 'A',
          album: 'B',
          category: RecordCategory.ROCK,
          format: RecordFormat.VINYL,
        },
      ];

      mockRecordModel.exec.mockResolvedValue(mockRecords);

      const results = await service.findAll(
        10,
        0,
        'A',
        undefined,
        undefined,
        RecordFormat.VINYL,
        RecordCategory.ROCK,
      );
      expect(results).toHaveLength(1);
    });
  });
});

================
File: src/modules/records/services/record.service.ts
================
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { CreateRecordRequestDTO } from '../dtos/create-record.request.dto';
import { Record } from '../schemas/record.schema';
import { Model } from 'mongoose';
import { InjectModel } from '@nestjs/mongoose';
import { UpdateRecordRequestDTO } from '../dtos/update-record.request.dto';
import { RecordCategory, RecordFormat } from '../schemas/record.enum';
import { MusicBrainzService } from 'src/utils/api';
import { Track } from 'src/utils/dto';
import { CreateOrderRequestDTO } from '../dtos/create-order.request.dto';
import { TrackListDTO } from '../dtos/track-list.request.dto';
import { IRecordService } from '../interfaces/record.service.interface';

@Injectable()
export class RecordService implements IRecordService {
  constructor(
    @InjectModel('Record') private readonly recordModel: Model<Record>,
    private readonly musicBrainzService: MusicBrainzService,
  ) {}

  async create(payload: CreateRecordRequestDTO): Promise<Record> {
    try {
      const recordData = { ...payload };

      if (payload.mbid) {
        const release = await this.musicBrainzService.getReleaseData(
          payload.mbid,
        );
        if (release) {
          const tracks = release?.media?.[0]?.tracks;
          recordData.trackList = this.enrichPayload(tracks);
        }
      }

      return this.recordModel.create(recordData);
    } catch (error) {
      throw new Error(`Error creating record: ${error.message}`);
    }
  }

  async update(id: string, payload: UpdateRecordRequestDTO): Promise<Record> {
    try {
      const record = await this.recordModel.findById(id);
      if (!record) {
        throw new InternalServerErrorException('Record not found');
      }

      if (payload.mbid && payload.mbid !== record.mbid) {
        const release = await this.musicBrainzService.getReleaseData(
          payload.mbid,
        );
        if (release) {
          const tracks = release?.media?.[0]?.tracks;
          payload.trackList = this.enrichPayload(tracks);
        }
      }

      const updated = await this.recordModel.updateOne({
        ...record,
        ...payload,
      });

      if (!updated) {
        throw new InternalServerErrorException('Failed to update record');
      }

      return record;
    } catch (error) {
      throw new Error(`Error updating record: ${error.message}`);
    }
  }

  async findById(id: string): Promise<Record> {
    try {
      const record = await this.recordModel.findById(id);
      if (!record) {
        throw new InternalServerErrorException('Record not found');
      }
      return record;
    } catch (error) {
      throw new Error(`Error finding record: ${error.message}`);
    }
  }

  async checkRecordAvailability(
    payload: CreateOrderRequestDTO,
  ): Promise<boolean> {
    try {
      const record = await this.findById(payload.recordId);
      return record.qty >= payload.qty;
    } catch (error) {
      throw new Error(`Error checking record availability: ${error.message}`);
    }
  }

  async findAll(
    limit: number = 10,
    skip: number = 0,
    q?: string,
    artist?: string,
    album?: string,
    format?: RecordFormat,
    category?: RecordCategory,
  ): Promise<{ data: Record[]; total: number }> {
    const query: any = {};

    if (q) {
      query.$or = [
        { artist: { $regex: q, $options: 'i' } },
        { album: { $regex: q, $options: 'i' } },
        { category: { $regex: q, $options: 'i' } },
      ];
    }

    if (artist) query.artist = { $regex: artist, $options: 'i' };
    if (album) query.album = { $regex: album, $options: 'i' };
    if (format) query.format = format;
    if (category) query.category = category;

    const response = await this.recordModel
      .find(query)
      .limit(limit)
      .skip(skip)
      .exec();

    const count = await this.recordModel.countDocuments(query);

    return {
      data: response,
      total: count,
    };
  }

  private enrichPayload(tracks: Track[]): TrackListDTO[] {
    if (!tracks?.length) return [];
    return tracks.map((track) => {
      const { id, title, length, disambiguation, video } = track.recording;
      return {
        id,
        title,
        length,
        disambiguation,
        video,
        firstReleaseDate: track.recording['first-release-date'],
      };
    });
  }
}

================
File: src/modules/records/record.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { RecordController } from './controllers/record.controller';
import { RecordService } from './services/record.service';
import { RecordSchema } from './schemas/record.schema';
import { MusicBrainzService } from 'src/utils/api';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Record', schema: RecordSchema }]),
  ],
  controllers: [RecordController],
  providers: [RecordService, MusicBrainzService],
})
export class RecordModule {}

================
File: src/utils/api.ts
================
import { Injectable } from '@nestjs/common';
import { IMusicBrainz } from './IMusicBrainz.interface';
import { request } from 'undici';
import { Release } from './dto';

@Injectable()
export class MusicBrainzService implements IMusicBrainz {
  async getReleaseData(mbid: string): Promise<Release> {
    const { body } = await request<Release>(
      `${process.env.MUSICBIZ_API_URL}/release/${mbid}?&inc=recordings&fmt=json`,
      {
        headers: {
          'User-Agent': 'nestjs-challenge/1.0.0 (lucas.germano@gmail.com)',
        },
      },
    );

    return (await body.json()) as Release;
  }
}

================
File: src/utils/dto.ts
================
export type Release = {
  id: string;
  title: string;
  date: string;
  country: string;
  status: string;
  statusId: string;
  packaging: string | null;
  packagingId: string | null;
  barcode: string | null;
  asin: string | null;
  quality: string;
  disambiguation: string;
  textRepresentation: {
    script: string;
    language: string;
  };
  releaseEvents: ReleaseEvent[];
  media: Media[];
  coverArtArchive: CoverArtArchive;
};

export type ReleaseEvent = {
  date: string;
  area: {
    id: string;
    name: string;
    'iso-3166-1-codes': string[];
    disambiguation: string;
    type: string | null;
    'type-id': string | null;
    'sort-name': string;
  };
};

export type Media = {
  position: number;
  title: string;
  format: string;
  formatId: string;
  trackCount: number;
  trackOffset: number;
  tracks: Track[];
};

export type Track = {
  id: string;
  title: string;
  number: string;
  length: number;
  position: number;
  recording: Recording;
};

export type Recording = {
  id: string;
  title: string;
  length: number;
  disambiguation: string;
  video: boolean;
  'first-release-date': string;
};

export type CoverArtArchive = {
  count: number;
  artwork: boolean;
  front: boolean;
  back: boolean;
  darkened: boolean;
};

================
File: src/utils/IMusicBrainz.interface.ts
================
import { Release } from './dto';

export interface IMusicBrainz {
  getReleaseData: (mbid: string) => Promise<Release>;
}

================
File: src/app.config.ts
================
import * as dotenv from 'dotenv';

dotenv.config();

export const AppConfig = {
  mongoUrl: process.env.MONGO_URL,
  port: process.env.PORT || 3000,
  rabbitMQUrl: process.env.RABBITMQ_URL || 'amqp://localhost:5672',
  rabbitMQQueue: process.env.RABBITMQ_QUEUE || 'orders-queue',
};

================
File: src/app.module.ts
================
import { Module } from '@nestjs/common';
import { RecordModule } from './modules/records/record.module';
import { MongooseModule } from '@nestjs/mongoose';
import { AppConfig } from './app.config';
import { OrdersModule } from './modules/orders/orders.module';
import { ClientsModule, Transport } from '@nestjs/microservices';

@Module({
  imports: [
    MongooseModule.forRoot(AppConfig.mongoUrl),
    RecordModule,
    OrdersModule,
    ClientsModule.register([
      {
        name: 'ORDERS_SERVICE',
        transport: Transport.RMQ,
        options: {
          noAck: false,
          urls: ['amqp://localhost:5672'],
          queue: 'orders-queue',
        },
      },
    ]),
  ],
  controllers: [],
  providers: [],
})
export class AppModule {}

================
File: src/main.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { AppConfig } from './app.config';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger'; // Import Swagger
import { ValidationPipe } from '@nestjs/common';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Agent, interceptors, setGlobalDispatcher } from 'undici';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';

async function bootstrap() {
  // Interceptors to add response caching, DNS caching and retrying to the dispatcher
  const { cache, dns, retry } = interceptors;
  const defaultDispatcher = new Agent({
    connections: 100, // Limit concurrent kept-alive connections to not run out of resources
    headersTimeout: 10_000, // 10 seconds; set as appropriate for the remote servers you plan to connect to
    bodyTimeout: 10_000,
  }).compose(cache(), dns(), retry());
  setGlobalDispatcher(defaultDispatcher); // Add these interceptors to all `fetch` and Undici `request` calls

  // Swagger configuration
  const config = new DocumentBuilder()
    .setTitle('Record API')
    .setDescription('The record management API')
    .build();

  const app = await NestFactory.create<NestFastifyApplication>(
    AppModule,
    new FastifyAdapter({ logger: true }),
  );
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('swagger', app, document);
  await app.listen(AppConfig.port);

  await app.connectMicroservice<MicroserviceOptions>({
    transport: Transport.RMQ,
    options: {
      urls: [AppConfig.rabbitMQUrl],
      queue: AppConfig.rabbitMQQueue,
    },
  });

  app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
      whitelist: true,
    }),
  );

  await app.startAllMicroservices();
}
bootstrap();

================
File: test/jest-e2e.json
================
{
  "moduleFileExtensions": [
    "js",
    "json",
    "ts"
  ],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  },
  "testPathIgnorePatterns": [
    "/node_modules/"
  ]
}

================
File: test/record.e2e-spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';
import {
  RecordFormat,
  RecordCategory,
} from '../src/modules/records/schemas/record.enum';

describe('RecordController (e2e)', () => {
  let app: INestApplication;
  let recordId: string;
  let recordModel;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    recordModel = app.get('RecordModel');
    await app.init();
  });

  // Test to create a record
  it('should create a new record', async () => {
    const createRecordDto = {
      artist: 'The Beatles',
      album: 'Abbey Road',
      price: 25,
      qty: 10,
      format: RecordFormat.VINYL,
      category: RecordCategory.ROCK,
    };

    const response = await request(app.getHttpServer())
      .post('/records')
      .send(createRecordDto)
      .expect(201);

    recordId = response.body._id;
    expect(response.body).toHaveProperty('artist', 'The Beatles');
    expect(response.body).toHaveProperty('album', 'Abbey Road');
  });

  it('should create a new record and fetch it with filters', async () => {
    const createRecordDto = {
      artist: 'The Fake Band',
      album: 'Fake Album',
      price: 25,
      qty: 10,
      format: RecordFormat.VINYL,
      category: RecordCategory.ROCK,
    };

    const createResponse = await request(app.getHttpServer())
      .post('/records')
      .send(createRecordDto)
      .expect(201);

    recordId = createResponse.body._id;

    const response = await request(app.getHttpServer())
      .get('/records?artist=The Fake Band')
      .expect(200);
    expect(response.body.length).toBe(1);
    expect(response.body[0]).toHaveProperty('artist', 'The Fake Band');
  });
  afterEach(async () => {
    if (recordId) {
      await recordModel.findByIdAndDelete(recordId);
    }
  });

  afterAll(async () => {
    await app.close();
  });
});

================
File: .env.sample
================
PORT=
MONGO_URL=
MUSICBIZ_API_URL=
RABBITMQ_URL=
RABBITMQ_QUEUE=

================
File: .eslintrc.js
================
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
  },
};

================
File: .gitignore
================
# compiled output
/dist
/node_modules
/.scannerwork

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/test/coverage/
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.clinic

================
File: .prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "all"
}

================
File: CHALLENGE.md
================
🚀 **Welcome to the Broken Record Store API Challenge!** 🚀
===========================================================

Welcome to the **Broken Record Store**—where the records never stop spinning (unless the server goes down). We're proud to present the **award-winning API** that powers our point of sale system. We're constantly looking to improve and innovate. So, we’ve come up with a few **rocket science features** that you, as a top-tier developer, will be tasked with improving.

🏆 **The Award-Winning API** 🏆
-------------------------------

Our **API** provides groundbreaking features like:

*   Saving a record
    
*   Editing a record
    
*   Filtering records by any number of parameters (because who doesn’t love a good filter?)
    

### 🎵 **What is a Record?**

At **Broken Record Store**, a record is much more than just vinyl. It’s the core of our business and the thing that our API interacts with the most. Let’s break down the **record** fields:

#### **Fields in the Record DTO**:

*   **artist**: The artist who made the album. Example: _The Beatles_.
    
*   **album**: The name of the album. Example: _Abbey Road_.
    
*   **price**: The price of the record in your currency. Example: _$20_.
    
*   **qty**: The quantity of records available in stock.
    
*   **format**: The format of the record (e.g., _Vinyl_, _CD_).
    
*   **category**: The genre or category of the record (e.g., _Rock_, _Jazz_).
    
*   **mbid**: The **MusicBrainz Identifier** for the album. This is a **universal identifier** for the album. You can find it at [MusicBrainz](https://musicbrainz.org/). Example: b10bbbfc-cf9e-42e0-be17-e2c3e1d2600d.
    

#### **Categories**:

*   **Rock**
    
*   **Pop**
    
*   **Jazz**
    
*   **Indie**
    
*   **Alternative**
    
*   **Classical**
    
*   **Hip-Hop**
    

#### **Formats**:

*   **Vinyl**
    
*   **CD**
    
*   **Cassette**
    
*   **Digital**
    

### 📚 **What Should Uniquely Identify a Record?**

We believe a **record** should be uniquely identified by a **combination of**:

*   **artist**
    
*   **album**
    
*   **format**
    

The **MBID** from [MusicBrainz](https://musicbrainz.org/) is a **universal identifier** that helps us get more details about the album, like **track listings**. It's like an **ID card** for your record!

🛠️ **Current Problems with the API**
-------------------------------------

Our **production database** currently holds a **huge collection** of **100,000 records**. But unfortunately, searches are a little slow. And when I say **slow**, I mean **like waiting for a needle drop in slow motion**. 🎶

Some of the challenges:

*   **All searches take a long time**, especially as our catalog grows.
    
*   The **API** is **not fetching record details from MusicBrainz** to automatically populate track lists when creating or editing records. This means we're missing out on **rich, detailed data**.
    
*   **Scalability** issues: Searching through **100,000 records** is starting to feel like searching for a needle in a haystack. But worse. 🤦‍♂️
    

💡 **What We Need From You** 💡
-------------------------------

### 1\. **Analyze the Current Setup**

Look through the current API and suggest any **improvements**. Some of the things to focus on:

*   **Improving search performance**.
    
*   **Reducing load times**.
    
*   **Optimizing database queries**.
    

### 2\. **Record Creation with MBID**

When creating a **new record** and providing a **MBID**:

*   We want to **fetch record information** from the MusicBrainz API (use **XML** response format for reference).
    
*   If the **MBID is valid** (i.e., MusicBrainz API returns data), we want to:
    
    *   Extract the **track listing** and store it in the tracklist array in the record model.
        

### 3\. **Record Editing with MBID**

When **editing an existing record** and updating the **MBID**:

*   If the **MBID** provided is **different** than the previous one, repeat the process of fetching track information from MusicBrainz and **update the tracklist**.
    

### 4\. **Create Orders with Record ID + Quantity**

We need to implement the ability to create **orders** for records. An order will need:

*   **Record ID**.
    
*   **Quantity** of records being ordered.
    

🚀 **Extra Tasks to Add?** 🚀
-----------------------------

You can also think of a few improvements or add tasks that will make the **Broken Record Store** API stand out even more:

*   **Pagination** for large sets of records.
    
*   **Caching** record queries for faster access.
    
*   Maybe even an **admin panel** to easily add records to the database? 🤔
    

📝 **Bonus Points** 🎯
----------------------

*   **Code quality**: Clean, well-structured, and modular code.
    
*   **Testing**: Ensure your changes are **fully tested**.
    
    *   **Unit Tests** for your logic.
        
    *   **End-to-End Tests** to make sure the app is fully functional.
        
    *   **Coverage**: Run tests with coverage enabled.
        

🌟 **Have Fun!** 🌟
-------------------

Remember, this challenge is all about **creativity**, **problem-solving**, and **improving the user experience**. The **Broken Record Store** is counting on you to make this **API the best it can be**. We know you’ve got the skills to turn things around, and we can’t wait to see your solution!

Good luck and may your code be bug-free! 🐛💻✨

================
File: data.json
================
[
  {
    "artist": "Sisters of Mercy",
    "album": "First and Last and Always",
    "price": 20,
    "qty": 3,
    "format": "Vinyl",
    "category": "Alternative",
    "mbid": "63823c15-6abc-473e-9fad-d0d0fa983b34"
  },
  {
    "artist": "Joy Division",
    "album": "Unknown Pleasures",
    "price": 25,
    "qty": 10,
    "format": "CD",
    "category": "Alternative",
    "mbid": "3dd3e849-5830-429a-ac81-75054fe1d720"
  },
  {
    "artist": "Chameleons",
    "album": "Script of the Bridge",
    "price": 18,
    "qty": 2,
    "format": "Vinyl",
    "category": "Alternative",
    "mbid": "21c47b6a-4c66-32ea-b67d-0987ba2a0a59"
  },
  {
    "artist": "Pearl Jam",
    "album": "Ten",
    "price": 22,
    "qty": 8,
    "format": "CD",
    "category": "Rock",
    "mbid": "ead8be7c-5252-4f86-9cad-b7c98aef226d"
  },
  {
    "artist": "Nirvana",
    "album": "Nevermind",
    "price": 20,
    "qty": 10,
    "format": "Vinyl",
    "category": "Rock",
    "mbid": "2feb350a-41c3-4358-addd-5b66ce2c34ba"
  },
  {
    "artist": "Franz Ferdinand",
    "album": "Franz Ferdinand",
    "price": 21,
    "qty": 90,
    "format": "Vinyl",
    "category": "Indie",
    "mbid": "af6691d1-12b2-4238-8380-682daa2754e3"
  },
  {
    "artist": "Arctic Monkeys",
    "album": "AM",
    "price": 24,
    "qty": 3,
    "format": "Vinyl",
    "category": "Indie",
    "mbid": "bf584cf2-dc33-433e-b8b2-b85578822726"
  },
  {
    "artist": "Foo Fighters",
    "album": "Foo Fighers",
    "price": 8,
    "qty": 10,
    "format": "CD",
    "category": "Rock",
    "mbid": "d6591261-daaa-4bb2-81b6-544e499da727"
  },
  {
    "artist": "The Cure",
    "album": "Disintegration",
    "price": 23,
    "qty": 1,
    "format": "Vinyl",
    "category": "Alternative",
    "mbid": "11af85e2-c272-4c59-a902-47f75141dc97"
  },
  {
    "artist": "The Smiths",
    "album": "The Queen Is Dead",
    "price": 28,
    "qty": 5,
    "format": "Vinyl",
    "category": "Alternative",
    "mbid": "3166b55c-17db-3a92-87f7-3b62d0222c46"
  },
  {
    "artist": "The Smiths",
    "album": "The Queen Is Dead",
    "price": 10,
    "qty": 10,
    "format": "CD",
    "category": "Alternative",
    "mbid": "fd0da5e1-fbb4-3a6c-a575-929b78a272c3"
  }
]

================
File: docker-compose-mongo.yml
================
version: '3.8'

services:
  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq
    hostname: rabbitmq
    volumes:
      - /var/lib/rabbitmq
    ports:
      - '5672:5672'
      - '15672:15672'
    env_file:
      - .env

  mongodb:
    image: mongo:latest
    command: --replSet rs0
    ports:
      - '27017:27017'
    environment:
      MONGO_INITDB_DATABASE: records
    healthcheck:
      # use 'mongo' instead of 'mongosh' if MongoDB version is lower than 5
      test: mongosh --eval 'db.runCommand("ping").ok' localhost:27017/test --quiet
      interval: 2s
      timeout: 3s
      retries: 5

  mongo-init:
    image: mongo:latest
    restart: 'no'
    depends_on:
      mongodb:
        condition: service_healthy
    command: >
      mongosh --host mongodb:27017 --eval
      '
      rs.initiate( {
         _id : "rs0",
         members: [
            { _id: 0, host: "localhost:27017" }
         ]
      })
      '

================
File: jest.config.ts
================
import { Config } from 'jest';

const config: Config = {
  moduleFileExtensions: ['js', 'json', 'ts'],
  rootDir: './',
  testRegex: '.spec.ts$',
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  moduleNameMapper: {
    '^src/(.*)$': '<rootDir>/src/$1',
  },
  collectCoverageFrom: ['**/src/**/*.ts'],
  coverageDirectory: './coverage',
  testEnvironment: 'node',
};

export default config;

================
File: nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

================
File: package.json
================
{
  "name": "nestjs-hostelworld-challenge",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "mongo:start": "docker compose -f ./docker-compose-mongo.yml up -d",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json --detectOpenHandles --forceExit",
    "setup:db": "ts-node -r tsconfig-paths/register setup-db.ts"
  },
  "dependencies": {
    "@fastify/static": "^8.1.1",
    "@nestjs/common": "^11.0.0",
    "@nestjs/core": "^11.0.0",
    "@nestjs/microservices": "^11.0.17",
    "@nestjs/mongoose": "^11.0.1",
    "@nestjs/platform-express": "^11.0.0",
    "@nestjs/platform-fastify": "^11.0.16",
    "@nestjs/swagger": "^11.0.6",
    "amqp-connection-manager": "^4.1.14",
    "amqplib": "^0.10.7",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "dotenv": "^16.4.7",
    "mongoose": "^8.11.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.1",
    "swagger-ui-express": "^5.0.1",
    "undici": "^7.8.0"
  },
  "devDependencies": {
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.0",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.2",
    "@types/node": "^20.3.1",
    "@types/supertest": "^2.0.12",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.7.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  }
}

================
File: README.md
================
# Record Store Challenge API
## Description

This is a **NestJS** application starter with MongoDB integration. If necessary, it provides a script to boot a Mongo emulator for Docker. This setup includes end-to-end tests, unit tests, test coverage, linting, and database setup with data from `data.json`.

## Installation

### Install dependencies:

```bash
$ npm install
````

### Docker for MongoDB Emulator
To use the MongoDB Emulator, you can start it using Docker:
```
npm run mongo:start
```
This will start a MongoDB instance running on your local machine. You can customize the settings in the Docker setup by modifying the docker-compose-mongo.yml if necessary. In the current configuration, you will have a MongoDB container running, which is accessible at localhost:27017.
This mongo url will be necessary on the .env file, with example as follows:

```
MONGO_URL=mongodb://localhost:27017/records
```
This will point your application to a local MongoDB instance.

### MongoDB Data Setup
The data.json file contains example records to seed your database. The setup script will import the records from this file into MongoDB.

To set up the database with the example records:

```
npm run setup:db
```
This will prompt the user to cleanup (Y/N) existing collection before importing data.json


#### data.json Example
Here’s an example of the data.json file that contains records:
```
[
    {
        "artist": "Foo Fighters",
        "album": "Foo Fighers",
        "price": 8,
        "qty": 10,
        "format": "CD",
        "category": "Rock",
        "mbid": "d6591261-daaa-4bb2-81b6-544e499da727"
  },
  {
        "artist": "The Cure",
        "album": "Disintegration",
        "price": 23,
        "qty": 1,
        "format": "Vinyl",
        "category": "Alternative",
        "mbid": "11af85e2-c272-4c59-a902-47f75141dc97"
  },
]
```

### Running the App
#### Development Mode
To run the application in development mode (with hot reloading):

```
npm run start:dev
```
#### Production Mode
To build and run the app in production mode:

```
npm run start:prod
```

### Tests
#### Run Unit Tests
To run unit tests:

```
npm run test
```
To run unit tests with code coverage:

```
npm run test:cov
```
This will show you how much of your code is covered by the unit tests.
#### Run End-to-End Tests
To run end-to-end tests:
```
npm run test:e2e
```
Run Tests with Coverage


Run Linting
To check if your code passes ESLint checks:

```
npm run lint
```
This command will show you any linting issues with your code.

================
File: setup-db.ts
================
import * as mongoose from 'mongoose';
import {
  Record,
  RecordSchema,
} from './src/modules/records/schemas/record.schema';
import * as fs from 'fs';
import { AppConfig } from './src/app.config';
import * as readline from 'readline';

async function setupDatabase() {
  try {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    rl.question(
      'Do you want to clean up the existing records collection? (Y/N): ',
      async (answer) => {
        rl.close();

        const data = JSON.parse(fs.readFileSync('data.json', 'utf-8'));
        const recordModel: mongoose.Model<Record> = mongoose.model<Record>(
          'Record',
          RecordSchema,
        );

        await mongoose.connect(AppConfig.mongoUrl);

        if (answer.toLowerCase() === 'y') {
          await recordModel.deleteMany({});
          console.log('Existing collection cleaned up.');
        }

        const records = await recordModel.insertMany(data);
        console.log(`Inserted ${records.length} records successfully!`);

        mongoose.disconnect();
      },
    );
  } catch (error) {
    console.error('Error setting up the database:', error);
    mongoose.disconnect();
  }
}

setupDatabase();

================
File: SOLUTION.md
================
### **Architecture**

- https://app.ilograph.com/@lucassan/challenge

For the Orders functionality, how is the order system related to records? The answer is — it really shouldn’t be. These two domains should be decoupled, with no direct dependency between them.

So, I decided to create a new service called orders-service, which handles order placement independently. I also integrated a queue system using RabbitMQ to send an event whenever a new order is placed.

The record-service acts as a consumer for this event. When it receives the message, it processes it by updating the stock — specifically, decreasing the quantity of the records involved in the order.

Additionally, I believe we should consider introducing a dedicated inventory-service to better encapsulate and manage all stock-related responsibilities moving forward.

So, with this solution we can achieve a more loosely coupled architecture

### Improvements Ideas

- Create a Inventory-Service
- Create the Infrastructure (Cloud based)
- ElasticSearch or Algolia to Search

**High Availability**

- Deploy in multiple Availability Zones (configure it on Subnet level)
- On Database layer we can configure a RDS Multi-AZ

**High Scalability**

- Auto Scaling (Horizontal by default)
- Load Balancer to route the traffic

**Fault Tolerance**

- Maybe backup & restore strategy

**Performance**

- Caching ✅
- Pagination ✅
- CDN (CloudFront that will use Edge Locations)
- For the Search feature, add Algolia to it

**DoD (Definition Of Done)**

- All tests passing and with at least 80% branch cover
- Green Pipeline
- Code Review
- QA Tests
- docs

================
File: tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}
